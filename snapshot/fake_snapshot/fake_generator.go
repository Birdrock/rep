// This file was generated by counterfeiter
package fake_snapshot

import (
	"sync"

	"github.com/cloudfoundry-incubator/executor"
	"github.com/cloudfoundry-incubator/rep/snapshot"
	"github.com/pivotal-golang/lager"
	"github.com/pivotal-golang/operationq"
)

type FakeGenerator struct {
	BatchOperationsStub        func(lager.Logger) ([]operationq.Operation, error)
	batchOperationsMutex       sync.RWMutex
	batchOperationsArgsForCall []struct {
		arg1 lager.Logger
	}
	batchOperationsReturns struct {
		result1 []operationq.Operation
		result2 error
	}
	ContainerOperationStub        func(lager.Logger, executor.Container) (operationq.Operation, error)
	containerOperationMutex       sync.RWMutex
	containerOperationArgsForCall []struct {
		arg1 lager.Logger
		arg2 executor.Container
	}
	containerOperationReturns struct {
		result1 operationq.Operation
		result2 error
	}
}

func (fake *FakeGenerator) BatchOperations(arg1 lager.Logger) ([]operationq.Operation, error) {
	fake.batchOperationsMutex.Lock()
	fake.batchOperationsArgsForCall = append(fake.batchOperationsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.batchOperationsMutex.Unlock()
	if fake.BatchOperationsStub != nil {
		return fake.BatchOperationsStub(arg1)
	} else {
		return fake.batchOperationsReturns.result1, fake.batchOperationsReturns.result2
	}
}

func (fake *FakeGenerator) BatchOperationsCallCount() int {
	fake.batchOperationsMutex.RLock()
	defer fake.batchOperationsMutex.RUnlock()
	return len(fake.batchOperationsArgsForCall)
}

func (fake *FakeGenerator) BatchOperationsArgsForCall(i int) lager.Logger {
	fake.batchOperationsMutex.RLock()
	defer fake.batchOperationsMutex.RUnlock()
	return fake.batchOperationsArgsForCall[i].arg1
}

func (fake *FakeGenerator) BatchOperationsReturns(result1 []operationq.Operation, result2 error) {
	fake.BatchOperationsStub = nil
	fake.batchOperationsReturns = struct {
		result1 []operationq.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeGenerator) ContainerOperation(arg1 lager.Logger, arg2 executor.Container) (operationq.Operation, error) {
	fake.containerOperationMutex.Lock()
	fake.containerOperationArgsForCall = append(fake.containerOperationArgsForCall, struct {
		arg1 lager.Logger
		arg2 executor.Container
	}{arg1, arg2})
	fake.containerOperationMutex.Unlock()
	if fake.ContainerOperationStub != nil {
		return fake.ContainerOperationStub(arg1, arg2)
	} else {
		return fake.containerOperationReturns.result1, fake.containerOperationReturns.result2
	}
}

func (fake *FakeGenerator) ContainerOperationCallCount() int {
	fake.containerOperationMutex.RLock()
	defer fake.containerOperationMutex.RUnlock()
	return len(fake.containerOperationArgsForCall)
}

func (fake *FakeGenerator) ContainerOperationArgsForCall(i int) (lager.Logger, executor.Container) {
	fake.containerOperationMutex.RLock()
	defer fake.containerOperationMutex.RUnlock()
	return fake.containerOperationArgsForCall[i].arg1, fake.containerOperationArgsForCall[i].arg2
}

func (fake *FakeGenerator) ContainerOperationReturns(result1 operationq.Operation, result2 error) {
	fake.ContainerOperationStub = nil
	fake.containerOperationReturns = struct {
		result1 operationq.Operation
		result2 error
	}{result1, result2}
}

var _ snapshot.Generator = new(FakeGenerator)
