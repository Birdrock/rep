// This file was generated by counterfeiter
package fake_generator

import (
	"sync"

	"github.com/cloudfoundry-incubator/rep/generator"
	"github.com/pivotal-golang/lager"
	"github.com/pivotal-golang/operationq"
)

type FakeGenerator struct {
	BatchOperationsStub        func(lager.Logger) ([]operationq.Operation, error)
	batchOperationsMutex       sync.RWMutex
	batchOperationsArgsForCall []struct {
		arg1 lager.Logger
	}
	batchOperationsReturns struct {
		result1 []operationq.Operation
		result2 error
	}
	OperationStreamStub        func(lager.Logger) (<-chan operationq.Operation, error)
	operationStreamMutex       sync.RWMutex
	operationStreamArgsForCall []struct {
		arg1 lager.Logger
	}
	operationStreamReturns struct {
		result1 <-chan operationq.Operation
		result2 error
	}
}

func (fake *FakeGenerator) BatchOperations(arg1 lager.Logger) ([]operationq.Operation, error) {
	fake.batchOperationsMutex.Lock()
	fake.batchOperationsArgsForCall = append(fake.batchOperationsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.batchOperationsMutex.Unlock()
	if fake.BatchOperationsStub != nil {
		return fake.BatchOperationsStub(arg1)
	} else {
		return fake.batchOperationsReturns.result1, fake.batchOperationsReturns.result2
	}
}

func (fake *FakeGenerator) BatchOperationsCallCount() int {
	fake.batchOperationsMutex.RLock()
	defer fake.batchOperationsMutex.RUnlock()
	return len(fake.batchOperationsArgsForCall)
}

func (fake *FakeGenerator) BatchOperationsArgsForCall(i int) lager.Logger {
	fake.batchOperationsMutex.RLock()
	defer fake.batchOperationsMutex.RUnlock()
	return fake.batchOperationsArgsForCall[i].arg1
}

func (fake *FakeGenerator) BatchOperationsReturns(result1 []operationq.Operation, result2 error) {
	fake.BatchOperationsStub = nil
	fake.batchOperationsReturns = struct {
		result1 []operationq.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeGenerator) OperationStream(arg1 lager.Logger) (<-chan operationq.Operation, error) {
	fake.operationStreamMutex.Lock()
	fake.operationStreamArgsForCall = append(fake.operationStreamArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.operationStreamMutex.Unlock()
	if fake.OperationStreamStub != nil {
		return fake.OperationStreamStub(arg1)
	} else {
		return fake.operationStreamReturns.result1, fake.operationStreamReturns.result2
	}
}

func (fake *FakeGenerator) OperationStreamCallCount() int {
	fake.operationStreamMutex.RLock()
	defer fake.operationStreamMutex.RUnlock()
	return len(fake.operationStreamArgsForCall)
}

func (fake *FakeGenerator) OperationStreamArgsForCall(i int) lager.Logger {
	fake.operationStreamMutex.RLock()
	defer fake.operationStreamMutex.RUnlock()
	return fake.operationStreamArgsForCall[i].arg1
}

func (fake *FakeGenerator) OperationStreamReturns(result1 <-chan operationq.Operation, result2 error) {
	fake.OperationStreamStub = nil
	fake.operationStreamReturns = struct {
		result1 <-chan operationq.Operation
		result2 error
	}{result1, result2}
}

var _ generator.Generator = new(FakeGenerator)
